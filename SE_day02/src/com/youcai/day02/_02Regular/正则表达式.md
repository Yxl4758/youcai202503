##### 正则表达式

###### 一、简介

一种特殊的字符串，用于校验一段文本是否匹配某种模式，正则表达式不是java特有的，c、python中都可以用

##### 二、正则表达式语法

boolean matches(String regex)   校验某段字符串是否符合正则表达式匹配返回ture，否则返回false

String[] split(String regex)  将某段字符串按照正则表达式进行分割，返回一个字符串数组，保存分割后的字符串

replaceAll(String regex, String replacement) 将字符串中能够匹配上正则表达式的子串，替换为replacement字符串

replaceFirst(String regex, String replacement) 将字符串中第一个匹配到正则表达式的字串替换为replacement。

##### 三、字符集语法

|      []      |                表示匹配括号里的任意一个字符。                |
| :----------: | :----------------------------------------------------------: |
|    [abc]     |                 字符集。匹配a 或者 b 或者 c                  |
|    [^abc]    |                         反向字符集。                         |
|    [a-g]     |         字符范围。表示匹配所有的小写字母的任意一个。         |
|   [^*a-z*]   | 反向字符范围。匹配不在指定的范围内的任何字符。例如，"[^a-z]"匹配任何不在"a"到"z"范围内的任何字符。 |
|   [A-Za-z]   |         表示匹配所有的小写字母和大写字母的任意一个。         |
| [a-zA-Z0-9]  |      表示匹配所有的小写字母和大写字母和数字的任意一个。      |
| [a-z&&[^bc]] |     表示匹配所有的小写字母除了b和c, 只要匹配上就是true.      |
|      \d      |          用于匹配数字字符中的任意一个  相当于[0-9]           |
|      \D      |        用于匹配非数字字符中的任意一个   相当于[^0-9]         |
|      \w      |    匹配单词字符中的任意一个      单词字符就是[a-zA-Z0-9_]    |
|      \W      |                用于匹配非单词字符中的任意一个                |
|      \s      |      用于匹配空格，制表符，退格符，换行符等中的任意一个      |
|      \S      |     用于匹配非空格，制表符，退格符，换行符等中的任意一个     |
|      .       |                     用于匹配任意一个字符                     |
|              |                                                              |

在Java中有些字符需要 \ 字符进行转义

###### 四、量词语法

| X？    | 匹配0个或1个     |
| ------ | ---------------- |
| X*     | 匹配0个或1个以上 |
| X+     | 匹配1个以上      |
| X{n}   | 匹配n个          |
| X{m,}  | 匹配m个以上      |
| X{m,n} | 匹配m~n个        |
|        |                  |

###### 五、断言

(?=pattern)正向先行断言

​	

```
代表字符串中的一个位置，紧接该位置之后的字符序列能够匹配 pattern。
例如对 "a regular expression" 这个字符串，要想匹配 regular 中的 re，但不能匹配 expression 中的 re，可以用 re(?=gular)，该表达式限定了 re 右边的位置，这个位置之后是 gular，但并不消耗 gular 这些字符。
```

(?!pattern)负向先行断言

```
代表字符串中的一个位置，紧接该位置之后的字符序列不能匹配 pattern。
例如对 "regex represents regular expression" 这个字符串，要想匹配除 regex 和 regular 之外的 re，可以用 re(?!g)，该表达式限定了 re 右边的位置，这个位置后面不是字符 g。
负向和正向的区别，就在于该位置之后的字符能否匹配括号中的表达式。
```

(?<=pattern)正向后行断言

```
代表字符串中的一个位置，紧接该位置之前的字符序列能够匹配 pattern。
例如对 regex represents regular expression 这个字符串，有 4 个单词，要想匹配单词内部的 re，但不匹配单词开头的 re，可以用 (?<=\w)re，单词内部的 re，在 re 前面应该是一个单词字符。
之所以叫后行断言，是因为正则表达式引擎在匹配字符串和表达式时，是从前向后逐个扫描字符串中的字符，并判断是否与表达式符合，当在表达式中遇到该断言时，正则表达式引擎需要往字符串前端检测已扫描过的字符，相对于扫描方向是向后的
```

(?<!pattern)负向后行断言

```
代表字符串中的一个位置，紧接该位置之前的字符序列不能匹配 pattern。
例如对 "regex represents regular expression" 这个字符串，要想匹配单词开头的 re，可以用 (?<!\w)re。单词开头的 re，在本例中，也就是指不在单词内部的 re，即 re 前面不是单词字符。当然也可以用 \bre 来匹配。
```

##### 六、Pattern类

```
Pattern p=Pattern.compile("\\w+"); 
String regex = p.pattern();//返回 \w+ 
Matcher matcher = p.matcher("michael");
```

##### 七、Matcher类

```
String info = "名字:wulei  地址:hunan  电话:010-82350555";
Pattern p = Pattern.compile("(名字:\\w+\\s+)|(地址:\\w+\\s+)|(电话:\\d{3}-\\d{8})");
Matcher matcher = p.matcher(info);
```

Matcher类型的匹配方法

1.boolean matches()

​	整个字符串符合正则表达式返回true

2.boolean lookingAt()

​	字符串的开头符合正则表达时返回true

3.boolean find()

​	对字符串进行匹配,匹配到的子串可以在任何位置.。每次调用它，matcher里面的匹配指针都会向后移。

4. reset()

      重置find()的指针，lokingAt()会影响到find()查找的子字符串

Matcher类型的详情方法

1. `group()`
   1. 返回匹配到的子字符串
2. `group(int index)`
   1. 返回匹配到的子字符串里的第index个分组，group(0)=group()。
3. `start()`
   1. 返回匹配到的子字符串在字符串中的索引位置
4. `start(int index)`
   1. 返回匹配到的子字符串里的第index个分组开始的索引。
5. `end()`
   1. 返回匹配到的子字符串的最后一个字符在字符串中的索引位置+1
6. `end(int index)`
   1. 返回匹配到的子字符串里的第index个分组结束的索引+1。