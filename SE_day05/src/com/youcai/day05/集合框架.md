#### 集合框架

##### 一、什么是集合

集合是一个存储引用数据类型的可变数据容器，与数组类似。集合提供了很多对于数据进行操作的方法。集合中只能存储引用数据类型，不能存储八大基本数据类型。八大基本数据类型要存储到集合中，需要将其转换成各自对应的包装类。

###### 1.1 集合与数组的区别：

1. 集合是一个可变的容器，可以随时进行增删操作。数组是一个不可变的容器，需要通过System.arrayCopy实现变相的扩容。
2. 数组中可以存储引用数据类型和基本数据类型。集合中只能保存引用数据类型。
3. 数组只能通过下标进行访问，操作麻烦。集合中提供了很多对数据的操作。

![](F:\Java培训\typroa图片\集合1.png)

###### 1.2集合的体系架构

![](F:\Java培训\typroa图片\集合体系架构.png)

##### 二、父接口Collection

###### 2.1 简介

是List、Set、Queue的父接口，定义了三个子接口的共同方法。子类集合存储的对象可能是无序的也可能是有序的，所以在父接口，没有定义通过下标获取元素的方法功能

###### 2.2常用方法

| 返回值类型  | 方法名                                                       |
| ----------- | :----------------------------------------------------------- |
| boolean     | add(E e)向集合中添加一个元素                                 |
| boolean     | addAll(Collection c)将指定集合c添加到集合中                  |
| void        | clear()清空集合里的元素                                      |
| boolean     | contains(Object o)返回集合中是否包含o元素                    |
| boolean     | cntainsAll(Collection c)返回集合中是否包含集合c中的所有元素  |
| boolean     | equals(Object o)将指定的对象与此集合进行比较以获得相等性。   |
| int         | hashCode()返回集合的哈希值                                   |
| boolean     | isEmpty()判断集合是否为空                                    |
| Iterator<E> | iterator()返回次集合的迭代器                                 |
| boolean     | remove(Object o)删除集合中的指定元素，若没有返回false        |
| boolean     | removeAll(Collection<?> c)在集合中删除集合c中含有的元素      |
| boolean     | retainAll(Collection<?> c)仅保留此集合中包含在指定集合中的元素 |
| int         | size()返回集合中元素的个数                                   |
| Object[]    | toArray()返回一个包含此集合中所有元素的数组。                |
| <T> T[]     | toArray()返回包含此集合中所有元素的数组; 返回的数组的运行时类型是指定数组的运行时类型。 |

###### 2.3集合的迭代

1）增强for循环

​	增强for循环中不允许对集合的元素进行修改，修改时无效的

​	增强for循环不能对集合的长度进行修改，否则会抛出					ConcurrentModiﬁcationException异常

2）迭代器Iterator

循环调用 next() 方法进行向后的元素指向，并返回新的指向的元素。同时，在向 后进行遍历的过程中，使用 hasNext() 判断是否还有下一个元素可以迭代。

​	不能使用集合的方法对集合进行修改

​	要修改集合需要使用Iterator提供的方法

```
// 1、获取迭代器对象，这里的   iterator 是一个  Iterator 接口的实现类对象
Iterator<String> iterator = collection.iterator();

// 2、使用迭代器进行集合的遍历
while (iterator.hasNext()) {
   // 让迭代器向后指向一位，并返回这一位的元素
   String element = iterator.next();
   System.out.println(element);
}
```

##### 三、子接口List

###### 3.1 简介

​	List是一个有序、可重复的集合，每个元素都有对应的下标，从0开始

​	List默认按照添加顺序设置元素的索引

​	List添加了一些根据索引操作集合元素的方法

###### 3.2ArrayList和LinkedList

两者对比：

​	ArraysList是实现了基于动态数组的数据结构，对象存储在连续的位置上

​	LinkedList基于双链表的数据结构，链表中的每个节点都包含了前一个和后一个节点的引用。

​	对于随机访问get和set，ArraysList绝对优于LinkedList，因为LinkedList要移动指针。

​	对于插入和删除操作，LinkedList比较占优势，因为ArraysList要移动数据。

![](F:\Java培训\typroa图片\ArraysList和LinkedList.png)

###### 3.3额外方法

| 返回值类型 | 方法名                                                       |
| ---------- | :----------------------------------------------------------- |
| E          | get(int index)返回指定位置的元素                             |
| int        | indexOf(Object obj)返回列表中指定元素第一次出现的位置，如果没有返回-1 |
| int        | lastIndexOf(Object obj)返回列表中指定元素最后一次出现的位置，如果没有返回-1 |
| E          | set(int index,E element)用指定元素替换指定位置上的元素，返回被替换出来的元素对象 |
| List       | subList(int fromIndex,int toIndex)截取子集，返回集合中指定的fromIndex 到 toIndex之间部分视图，包前不包后 |

###### 3.4ListIterator

ListIterator是Iterator接口的子接口，继承到了Iterator中所有的方法，同时自己也添加了若干个方法。 允许使用ListIterator在进行元素迭代的时候，对集合中的数据进行修改，或者对集合的长度进行修改。 同时，使用ListIterator还可以进行倒序的迭代。

ListIterator方法

| 返回值类型 | 方法名                                                       |
| :--------- | ------------------------------------------------------------ |
| void       | add(E e)将指定的元素插入列表                                 |
| boolean    | hasNext()是否含有下一个元素，若有返回ture                    |
| boolean    | hasPrevious()是否含有上一个元素，若有返回ture                |
| E          | next()返回集合中的下一个元素，并且前进光标位置。             |
| int        | nextIndex()返回随后调用 [`next()`](../../java/util/ListIterator.html#next--)返回的元素的索引。 |
| E          | previous()返回列表中的上一个元素，并向后移动光标位置。       |
| int        | previousIndex()返回由后续调用 [`previous()`](../../java/util/ListIterator.html#previous--)返回的元素的索引。 |
| void       | remove()从列表中删除由 [`next()`](../../java/util/ListIterator.html#next--)或 [`previous()`](../../java/util/ListIterator.html#previous--)返回的最后一个元素 |
| void       | set(E e)用 指定的元素替换由 [`next()`](../../java/util/ListIterator.html#next--)或 [`previous()`](../../java/util/ListIterator.html#previous--)返回的最后一个元素 |

##### 四、子接口Queue

###### 4.1简介

​	队列Queue也是Collection的一个子接口，它也是常用的数据结构，可以将队列看成特殊的线性表，队列限制对线性表的访问方式：只能从一端添加(offer)元素，从另一端取出（poll）元素。

​	队列遵循先进先出（FIFO  first Input First Output）的原则

​	实现类LinkedList也实现了该接口，选择此类实现Queue的原因在于Queue经常要进行添加和删除操作，而LinkedList在这方面效率比较高。

主要方法：

| 返回值类型 | 方法名                                               |
| :--------- | ---------------------------------------------------- |
| boolean    | offer(E e)将一个对象添加到队尾，如果添加成功返回true |
| E          | poll()从队首删除并返回这个元素                       |
| E          | peek()查看队首的元素                                 |

###### 4.2Deque

Deque是Queue的子接口，定义了所谓的”双端队列”，即从队列的两端分别可以入队（offer）和出队（poll）。同样，LinkedList实现了该接口.

如果将Deque限制为只能一端入队和出队，则可以实现“栈”(Stack)的数据结构,对于栈而言，入栈被称为push，出栈被称为pop。遵循先进后（FILO）出原则

```
	    Deque<String> deque = new LinkedList<>();
        //从队首进和出
        deque.offerFirst("A");
        deque.offerFirst("B");
        deque.offerFirst("C");
        //从队首出
        deque.pollFirst();
        deque.pollFirst();
        System.out.println(deque);
        //从队尾进和出
        deque.offerLast("X");
        deque.offerLast("Y");
        deque.offerLast("Z");
        System.out.println(deque);
        deque.pollLast();
        System.out.println(deque);
        System.out.println("———————————Dueue模拟Stack——————————");
        //只需要调用从队首进从队尾出。或者push和pop
        Deque<String> stack = new LinkedList<>();
        stack.push("A");
        stack.push("B");
        stack.push("C");
        stack.push("D");
        System.out.println(stack);
        while(stack.peek() != null) {
            System.out.println(stack.pop());
        }
```

##### 五、子接口Set

###### 5.1 简介

​	Set集合中的元素是无序的。Set集合中的元素不重复。

###### 5.2实现类

1）HashSet

HashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存取和查找性能。

​	不能保证元素的排列顺序

​	HashSet不是线程安全的

​	集合元素可以是null

​	先调用元素的hashcode方法经过Hash算法来计算存储的位置，如果该位置上没有元素就可以存储。如果该位置上有元素，再调用equals方法来比较两个元素是否相似如果相同就不存储，不同就存储

​	为了避免hashcode相同，equals不同，元素应该重写hashcode和equals方法

当想要自定义类型的对象存储到Set集合当中，需要重写hashcode和equals方法

​	将一个对象存储到set集合后，就不要再修改这个对象的属性了，否则找不到。存储时使用的是旧的hash值进行计算的，查找时使用的是新值查找的，极大概率是找不到的

2)LinkedHashSet

​	LinkedHashSet 是 HashSet 的子类

​	LinkedHashSet 集合根据元素的 hashCode 值来决定元素的存储位置，但它同时使用链表维护元素的次序，这使得元素看起来是以插入顺序保存的。

​	LinkedHashSet 性能插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能。

​	LinkedHashSet 不允许集合元素重复。

3)TreeSet

​	从写equals和hashcode方法

​	里面存储的元素必须实现Comparable接口

​	向TreeSet集合里添加元素时的去重原理实际上时调用重写的ComparTo方法

​	TreeSet还支持使用比较器进行自定义排序

```java
public class SetDemo03 {
    public static void main(String[] args) {
        Cat c1 = new Cat(2);
        Cat c2 = new Cat(3);
        Cat c3 = new Cat(2);
        Set<Cat> set = new TreeSet<>();
        set.add(c1);
        set.add(c2);
        set.add(c3);
        System.out.println(set);
        set.add(new Cat(1));
        System.out.println(set);
        //对上述的四只猫，添加到集合中进行年龄降序排序
        Set<Cat> set1 = new TreeSet<>(new Comparator<Cat>() {

            @Override
            public int compare(Cat o1, Cat o2) {
                return o2.getAge() - o1.getAge();
            }
        });
        set1.add(c1);
        set1.add(c2);
        set1.add(c3);
        set1.add(new Cat(1));
        System.out.println(set1);
    }
}
```

###### 六、List排序

1）Comparable接口

​	int  compareTo(T  t)  。规范了其子类是可以比较的，因此子类必须重写此抽象方法。（默认是升序）

2）Collections提供的排序方法

​	static  void  sort(List<T>  list)作用是对指定的集合元素进行自然排序。前提元素类型必须实现Comparable接口

3）Comparator比较器接口

​	int  compare(T  o1 , T  o2)

​	static  void        sort(List<T>  list , Comparator  c)使用比较器c，指定临时排序规则

4）Collections

| 排序操作                                                     | 查找替换                                                     |
| :----------------------------------------------------------- | ------------------------------------------------------------ |
| reverse(List)：反转 List 中元素的顺序                        | Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素 |
| shuffle(List)：对 List 集合元素进行随机排序                  | Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素 |
| sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序 | Object min(Collection)                                       |
| sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序 | Object min(Collection，Comparator)                           |
| swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换 | int frequency(Collection，Object)：返回指定集合中指定元素的出现次数 |
|                                                              | boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值 |

##### 七、父接口Map

###### 7.1Map简介

​	key和value必须是引用类型的数据

​	在Map集合中key不允许重复，value可以重复

​	key可以为null，但是只允许一个null

​	key-value是单向一对一关系，一个key对应一个value，一个value可能对应多个key。

###### 7.2常用方法

| 返回值类型          | 方法名                                                       |
| :------------------ | ------------------------------------------------------------ |
| void                | clear()从Map中移除所有映射关系                               |
| boolean             | containsKey(Object key)如果Map中包含Key则返回true            |
| boolean             | containsValue(Object value)如果Map中包含value对应的key返回true |
| Set<Map.Entry<K,V>> | entrySet()返回一个Set集合                                    |
| boolean             | equals(Object o)比较指定的对象与此映射是否相等               |
| V                   | get(Object key)返回key对应的value，若不存在返回null          |
| int                 | hasCode()返回此Map的哈希值                                   |
| boolean             | isEmpty()判断Map是否为空                                     |
| Set<K>              | keySet()返回Map中key的集合                                   |
| V                   | put(K key, V value)将指定的值与键关联                        |
| void                | putAll(Map m)将指定的Map添加到此Map中                        |
| V                   | remove(Object key)如果存在key则删除此映射                    |
| int                 | size()返回此Map中key-value的个数                             |
| Collection<V>       | value()返回包含值的集合                                      |

###### 7.3Map的遍历

1）遍历所有的key

​	Set<K>  keySet();

​	该方法会将当前Map中的所有key存入一个Set集合后返回

```
	Set<String> keys = scores.keySet();
        for (String key : keys) {
            System.out.println(key + ":" + scores.get(key));
        }
```

2）遍历所有的key-value

​	Set<Entry<K,V>>  entrySet()

​	该方法会将当前Map中的每一组key-value封装成Entry对象存入Set集合后返回

```
//使用EntrySet方式
        Set<Entry<String,Integer>> entries = scores.entrySet();
        for (Entry<String,Integer> entry : entries) {
            System.out.println(entry.getKey() + ":" + entry.getValue());
        }
```

3）遍历所有的value

​	Collection<V>  values

###### 7.4HashMap的实现原理

1）原理

![](F:\Java培训\typroa图片\Hash原理.png)

HashMap的底层主要是基于数组和链表来实现的，它之所以有相当快的查询速度主要是因为它是通过计算散列码来决定存储的位置。HashMap中主要是通过key的hashCode来计算hash值的，只要hashCode相同，计算出来的hash值就一样。如果存储的对象对多了，就有可能不同的对象所算出来的hash值是相同的，这就出现了所谓的hash冲突

2）装载因子及其HashMap优化

capacity:容量，hash表里bucket(桶)的数量，也就是散列数组大小

initial capacity:初始容量，创建hash表时，初始bucket的数量，默认构建容量为16，也可以使用特定容量。

size：大小，当前散列表中存储数据的数量

load factor:加载因子，默认值0.75也就是75%，当向散列表增加数据时，如果size/capacity的值大于loadfactor，则发生扩容并且重新散列(rebash)

性能优化：加载因子较小时，散列查找性能会提高，但是也浪费了散列桶空间容量。0.75是性能和空间相对平衡结果。在创建散列表时指定合理容量，减少rehash能提供性能

###### 7.5HashMap与HashTable

​	Hashtable 是一个古老的 Map 实现类，不建议使用

​	Hashtable 是一个线程安全的 Map 实现，但 HashMap 是线程不安全的。

​	Hashtable 不允许使用 null 作为 key 和 value，而 HashMap 可以

与 HashSet 集合不能保证元素的顺序的顺序一样，Hashtable 、HashMap 也不能保证其中 key-value 对的顺序。

###### 7.6LinkedHashMap

LinkedHashMap 是 HashMap 的子类

LinkedHashMap 可以维护 Map 的迭代顺序：迭代顺序与 Key-Value 对的插入顺序一致

底层维护了一个插入顺序的链表

###### 7.7TreeMap

TreeMap 存储 Key-Value对时，需要根据 Key 对 key-value 对进行排序。TreeMap 可以保证所有的 Key-Value 对处于有序状态。

注意：TreeMap里的key，是使用comparaTo来确定是否唯一的，而不是调用HashCode和equals的

​	自然排序：TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有的 Key 应该是同一个类的对象，否则将会抛出 ClassCastException

​	定制排序：创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key 实现 Comparable 接口

###### 7.8Properties

Properties 类是 Hashtable 的子类，该对象用于处理属性文件

由于属性文件里的 key、value 都是字符串类型，所以 properties 里的 Key 和 Value 都是字符串类型的

1. property

2.Properties是HashTable接口的子实现类，专门用来存储Key-value都是String类型的键值对

3.该类一般用来存储配置文件里的配置信息