## 线程

###### 一、什么是线程

1）线程与多线程

​	线程是进程中的一部分呢，是进程的最小运行单元。一个进程至少包含一个线程，即主线程。也可以有多个线程。线程不能独立存在，必须依赖进程。每个线程都有自己的指令指针、堆栈和局部变量。但他们共享进程的代码，数据和全局变量等资源。

2）线程与进程的区别

​	进程是操作系统运行的一个任务，线程是进程中运行的一个任务

​	进程是资源分配的最小单位(相互独立)，线程是进程执行的最小单位(cpu调度的基本单元)。

​	进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。进程之间的通信需要以IPC进行

​	线程是轻量级的进程，同一个进程中可以包含多个线程。多线程共享进程中的数据，使用相同的地址空间，因此，线程之间的通信更方便，CPU切换(或创建)一个线程的开销远比进程要小很多。

​	一个进程结束，其内的所有线程都结束，但不会对另外一个进程造成影响。多线程程序，一个线程结束，**有可能**会造成其他线程结束

3）时间片

​	在宏观上，我们可以同时打开多个应用程序，每个程序同时运行，互不打扰。但在微观上：由于只有一个CPU(一个内核而言)，一次只能运行某一个进程的某一个线程。如何公平处理，一种方法就是引入时间片的概念，每个程序轮流执行。

​	CPU调度机制算法，会将时间划分成一个个时间片，时间片的大小从几ms到几百ms。

4）同步与异步

**同步：**发出一个调用时，在没有得到结果之前，该调用就不反回

**异步：**在调用发出后，被调用者返回结果之后回通知调用者，或通过回调函数处理这个调用。

同步就是烧开水，要自己来看开没开；异步就是水开了，然后水壶响了通知你水开了（回调通知）。

###### 二、线程的基本应用

1）线程的创建

​	方法一：使用Thread的子类型

```
/**
 * Thread:  构造器
 *          Thread(Runnable target)
 *          Thread(Runnable target, String name)
 *          Thread(String name)
 * 线程的意义就是定义任务并执行。任务需要定义在run方法中。
 *
 * 创建线程的方式：
 *          - 使用Tread的子类型定义任务
 *              - 定义子类型
 *              - 使用匿名内部类
 */
public class ThreadDemo01 {
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            for(int i=1;i <= 100;i++){
                if(i % 2 != 0){
                    System.out.println(i);
                }
            }
        });
        Thread t2 = new MyThread();
        //调用start()方法启动线程
        t1.start();
        t2.start();
    }
}
//方式一：写法1
class MyThread extends Thread{
    public void run(){
        for(int i = 1;i <= 100;i++){
            if(i % 2 == 0){
                System.out.println(i);
            }
        }
    }
}
```

​	方式二：使用Runnable的子类型

```
/**
 * 第二种创建线程的方式：使用Runnable接口来定义任务
 *                      - 定义子类型
 *                      - 匿名内部类
 */
public class ThreadDemo02 {
    public static void main(String[] args) {
        Runnable r1 = new MyTask();
        Runnable r2 = () -> {
            for (int i = 1; i <= 100; i++) {
                if (i % 5 == 0) {
                    System.out.println(i);
                }
            }
        };
        Runnable r3 = () -> {
            for (int i = 1; i <= 100; i++) {
                if (i % 5 == 0 && i % 3 == 0) {
                    System.out.println(i);
                }
            }
        };
        //Thread t1 = new Thread(r1);
        //Thread t2 = new Thread(r2);
        Thread t3 = new Thread(r3);
        //t1.start();
        //t2.start();
        t3.start();
    }
}
class MyTask implements Runnable {

    @Override
    public void run() {
        for (int i = 1; i <= 100; i++) {
            if (i % 2 != 0) {
                System.out.println(i);
            }
        }
    }
}
```

​	方式三：Callable和FutureTask组合

```
/**
 * 创建线程的第三种方式：
 *      1. 创建Callable
 *      2. 创建FutureTask类型的对象，将Callable传入
 *      3. 创建Thread对象，将FutureTask传入进来
 */
public class ThreadDemo03 {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        Callable c = () -> {
            int x = new Random().nextInt(10);
            int y = new Random().nextInt(10);
            int z = new Random().nextInt(10);
            return x + y + z;
        };
        //get()有阻碍线程的方法
        FutureTask ft = new FutureTask<>(c);
        Thread thread = new Thread(ft);
        thread.start();
        System.out.println(ft.get());
    }
}
```

2）线程的生命周期

| 状态                   | 描述                                                         |
| ---------------------- | ------------------------------------------------------------ |
| 新建状态（New）        | 尚未启动的线程处于此状态（ 即还没有调用start()方法）         |
| 就绪状态（Runnable）   | 也可称为Ready状态。指已经调用了start()方法，并获取了内存资源，但没有获取cpu的时间片。 |
| 运行状态（Running）    | 线程获得CPU时间片，正在执行run()方法里的代码。               |
| 阻塞状态（Blocked）    | 阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。可再细分三种：1. **等待阻塞**：运行中的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。 2. **同步阻塞**：运行中的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。 3. **其他阻塞**：运行中的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。 |
| 死亡状态（Terminated） | 已经退出的线程处于此状态。退出的原因可能是run方法执行完毕、也可能是因为异常而中断了。 |

![](F:\Java培训\typroa图片\线程的生命周期.png)

为什么Java的进程状态源码中没有定义RUNNING状态

​	1.抽象层次不同

​	Java线程状态是JVM层面的抽象，而实际线程运行依赖于操作系统的线程调度。在操作系统中，线程通常有就绪（Ready）和运行（Running）两种状态。但是，JVM为了跨平台，将这两种状态合并为`RUNNABLE`，因为从Java程序的角度来看，这两种状态都是“可运行的”，只是是否正在占用CPU的区别。

​	2.状态转换的不可控性

​	线程何时从就绪状态变为运行状态（即获得CPU时间片）是由操作系统的线程调度器决定的，Java应用程序无法精确控制。因此，将这两种状态合并可以避免Java程序依赖于特定操作系统的调度行为，增强了可移植性。

​	3.简化模型

​	对于开发者而言，区分就绪和运行状态的实际意义不大。因为开发者无法通过Java API来区分这两种状态，也无法控制线程何时被调度执行。将两者合并为`RUNNABLE`状态，使得线程状态模型更简洁，更易于理解和使用。

​	4.监控与调试

​	在监控线程状态时（如使用jstack等工具），即使区分了运行中和就绪状态，对开发者解决问题的帮助也有限。因为线程在就绪状态和运行状态之间切换非常频繁，而且这种切换是操作系统调度的结果，开发者通常更关注线程是否在等待资源（如锁、I/O）等。

3）生命周期相关方法

| 返回值类型-方法名                 | 作用                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| `void start()`                    | 用来启动线程，使线程进入可运行状态，等待CPU分配时间片段      |
| `static void sleep(long millis)`  | 线程睡眠方法，使线程转到阻塞状态。millis参数设定睡眠的毫秒数。当睡眠结束后，就转为就绪（Runnable）状态。sleep()方法平台移植性好。 |
| `static void yield()`             | 线程让步方法，暂停当前正在执行的线程对象，使之处于可运行状态，把执行机会让给相同或者更高优先级的线程 |
| `void  join()`                    | 线程加入方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态 |
| `void interrupt()`                | 线程打断方法。 打断哪个线程，就用哪个线程对象调用。          |
| o.wait() o.notify() o.notifyAll() | 锁方法。使用锁对象调用，不是线程对象。                       |

4）线程的其他方法

| 返回值类型-方法名             | 作用                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| static Thread currentThread() | Thread类的静态方法,可以用于获取运行当前代码片段的线程对象    |
| long getId()                  | 返回该线程的标识符                                           |
| String getName()              | 返回该线程的名称                                             |
| int getPriority()             | 优先级被划分为10级，值分别为1-10，其中1最低，10最高。线程提供了三个常量来表示最低，最高，以及默认优先级返回该线程的优先级。<br />Thread.MIN_PRIORITY <br />Thread.MAX_PRIORITY <br />Thread.NORM_PRIORITY |
| Thread.State getState()       | 获取线程的状态                                               |
| boolean isAlive()             | 判断线程是否处于活动状态                                     |
| boolean isInterrupted()       | 判断线程是否已经中断                                         |
| boolean isDaemon()            | 判断线程是否为守护线程。守护线程的特点是，当进程中只剩下守护线程时，所有守护线程强制终止。**GC**就是运行在一个守护线程上的。 |

###### 三、临界资源问题

1）什么是临界资源

​	在一个进程中，多个线程之间是资源共享的。如果一个资源同时被多个线程访问，这个资源就是一个临界资源。

当多个线程并发读写同一个临界资源时，可能会发生**临界资源的安全隐患**问题，也称为**"线程并发安全问题"**。

2）线程锁机制

​	synchronized关键字

​	同步代码块包含两部分：一个是锁对象；一个是由这个锁保护的代码块

```
synchronized(同步监视器-锁对象引用){

  //代码块

}
```

每个Java对象都可以用作一个实现同步的锁。线程进入同步代码块之前会自动获得锁，并且在退出同步代码块时自动释放锁，无论是通过正常途径退出还是通过抛出异常退出都一样。**获取内置锁的唯一途径就是进入由这个锁保护的同步代码块或方法。**

synchronized作用在方法内部时，可以使用使用`成员属性`、`常量池中的对象`或者`this`作为锁对象。

```
public void run() {
    while(true){
        try {
            Thread.sleep(50);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        /**
         * 桌子上还有一个豆子。剩下一个豆子后，某一个人再次获取时间片段执行判断条件，条件成立，
         * 进入分支后恰好时间片段用完，紧接着下一个时间片段给了另外一个人，也去执行判断条件，条件也成立也进入了分支。
         * 此后，两个人不管谁先后获取时间片段，第二个人也进行了减豆子操作，就出现-1。
         */
        synchronized (desk){
            if(desk.getBeanNum() != 0){
                Thread.yield();
                takeBean();
            }else {
                break;
            }
        }
    }
}
```

synchronized作用在非静态方法上时，锁对象就是`this`。

synchronized作用在静态方法上时，锁对象是`类名.class`对象。

```
class Counter{
    private int count = 0;
    //将关键字放在非静态方法上时，锁对象是this 相当于synchronized(this){//代码片段包含了方法中的所有代码}
    public synchronized void add(){
        System.out.println(Thread.currentThread().getName() + "在调用add方法-start");
        int a = 10;
        int b = 20;
        int c = a + b;
        count++;
        int d = c + 30;
        System.out.println(Thread.currentThread().getName() + "在调用add方法-end");
    }

    /**
     *类名.class:     返回的是class类型的一个对象
     * Class:   用来描述其他类型的
     * Class的一个对象：用来描述一个具体类型
     * 如何得到一个Class的对象:只需要使用类名.class即可
     * Class的实例是单例的，即整个系统中，只有一个对象。
     *      String.class--->整个系统中只有一个
     *      Scanner.class--->整个系统中只有一个
     *      Counter.class--->整个系统中只有一个
     */
    public static synchronized void sum(int a, int b, int c){
        System.out.println(Thread.currentThread().getName() + "在调用add方法-start");
        int x = a*2;
        int y = b*2;
        int z = c*2;
        System.out.println("三个参数的二倍的和" + ( x + y + z));
        System.out.println(Thread.currentThread().getName() + "在调用add方法-end");
    }
}
```

3）锁的API

| 方法名      | 作用                                                         |
| ----------- | ------------------------------------------------------------ |
| wait()      | 等待，让当前的线程，释放自己持有的指定的锁标记，进入到等待队列。 |
|             | 等待队列中的线程，不参与CPU时间片的争抢，也不参与锁标记的争抢。 |
| notify()    | 通知、唤醒。随机唤醒等待队列中的一个等待这个锁标记的线程。   |
|             | 被唤醒的线程，进入到锁池，开始争抢锁标记。                   |
| notifuAll() | 通知、唤醒。唤醒等待队列中的所有的等待这个锁标记的线程       |
|             | 被唤醒的线程，进入到锁池，开始争抢锁标记。                   |

```java
/**
 * wait()
 * notify()
 * notifyAll()
 * 上述三个对象：锁对象的方法
 * 这三个方法需要同步块包裹
 * 同步代码块的意义：多个线程执行同一段逻辑，让其同步执行（串行）。可以解决临界资源安全隐患问题
 */
public class ThreadDemo02 {
    public static void main(String[] args) throws InterruptedException {
        //定义一个锁对象
        Object lock = new Object();
        Thread t1 = new Thread(() -> {
            synchronized (lock) {
                try {
                    System.out.println("t1：获取锁后并释放，开始进入等待队列");
                    lock.wait();
                    System.out.println("t1：开始执行-----");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                /**
                 * 下面的代码不再同步块中。因此t1和t2的该处代码的运行特点：可能交叉。
                 * 如果将其放入同步块中，t1和t2的该处代码的运行特点：不会交叉。
                 */
                for (int i = 0; i < 10; i++) {
                    System.out.println("t1: A");
                    try {
                        Thread.sleep(50);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                }
            }
        },"t1");
        Thread t2 = new Thread(() -> {
            synchronized (lock) {
                try {
                    System.out.println("t2：获取锁后并释放，开始进入等待队列");
                    lock.wait();
                    System.out.println("t2：开始执行-----");
                    for (int i = 0; i < 10; i++) {
                        System.out.println("t2: B");
                        try {
                            Thread.sleep(50);
                        } catch (InterruptedException e) {
                            throw new RuntimeException(e);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"t2");
        Thread t3 = new Thread(() -> {
            synchronized (lock) {
                System.out.println("t3：获取锁后通知等待队列中的某个线程，继续运行");
                lock.notifyAll();
            }
            for (int i = 0; i < 10; i++) {
                System.out.println("t3: C");
            }
        },"t3");
        t1.start();
        t2.start();
        //若想要t1、t2都先获取锁并进入等待队列。t3可以慢点执行
        Thread.sleep(1000);
        t3.start();
    }
}
```

###### 四、死锁

1）死锁的产生

​	死锁是指两个及以上进程互相等待对方资源释放而导致的一种阻塞现象

```Java
public class DeadLockDemo01{
     public static void main(String[] args){
        Runnable runnable1 = () -> {
           synchronized ("a") {
              System.out.println("线程A，持有了 a锁，在等待b锁 "); 
              synchronized ("b") {
                 System.out.println("线程A同时持有了a锁和b锁 ");
              }
           }
        };
        
        Runnable runnable2 = () -> {
           synchronized ("b") {
              System.out.println("线程B，持有了b锁，在等待a锁 "); 
              synchronized ("a") {
                 System.out.println("线程B同时持有了a锁和b锁 ");
              }
           }
        };
        
        new Thread(runnable1, "A").start();
        new Thread(runnable2, "B").start();
    }
}
```

2）死锁产生的必要条件

| 条件           |                                                              |
| -------------- | ------------------------------------------------------------ |
| **互斥**       | 当资源被一个线程占有时，别的线程不能使用                     |
| **不可抢占**   | 资源请求者不能强制从资源占有者手中夺取资源，资源只能由占有者主动释放 |
| **占有和等待** | 一个线程本身占有资源的同时还等待其他资源，而其他资源正被其他线程占有。 |
| **循环等待**   | 即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。这样就形成了一个等待环路。 |

3）死锁的解决方案

| 方案                 |                                                              |
| -------------------- | ------------------------------------------------------------ |
| **避免使用多把锁**   | 发生死锁就是因为使用了多个锁造成的，因此最直接的方式就是尽量避免使用多把锁 |
| **统一锁的获取顺序** | 在多线程中，如果不能避免使用多把锁，应该尽量保证所有线程获取锁的顺序是一致的。可以按照某种全局的规则来确定锁的获取顺序，例如按照对象的 hash 值来获取锁。 |
| **使用超时等待锁**   | 如果一个线程尝试获取锁时发现已经被其他线程占用，可以设置一个超时时间，超过这个时间就放弃获取锁。这样可以避免线程一直阻塞等待锁而导致死锁。 |
| **检测死锁**         | 可以定期检测系统中是否存在死锁，并且采取相应的措施来解决死锁问题。例如，可以使用 jstack 工具来查看死锁情况，或者使用死锁检测算法来自动检测死锁。 |

