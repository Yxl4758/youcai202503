#### 泛型

##### 一、定义

泛型是一种特殊的数据类型。他是Java的一个高级特性

类型参数化：使用形参接收具体类型名

数据参数化：使用形参接受具体数据

##### 二、应用

###### 2.1泛型类

```
/**
 * 泛型：类型参数化，真正使用时，给这个参数赋值一个类型名
 * 泛型类：
 *  1.  指的是泛型应用在类上，位置在类名后，使用<>括起来
 * */
public class Generic01Class {
    public static void main(String[] args) {
        Person<Integer> p = new Person<>(1000);
        System.out.println("p = " + p);
        Person<String> student = new Student<>("S0001","张三");
        System.out.println("student = " + student);
    }
}
//定义一个类型，要求有一个成员变量，该成员变量的类型是可变的，即参数化
class Person<T>{
    T id;
    public Person(){};
    public Person(T id){
        this.id = id;
    }

    @Override
    public String toString() {
        return "Person{" + "id=" + id + '}';
    }
}
//定义一个子类继承一个泛型类时，也是在应用泛型类，因此必须给泛型值赋值一个具体的类型名
//如果不给泛型赋值，则默认是Object类型，不会报错，只会警告
class Student<M> extends Person<M>{
    private M name;
    public Student(M id,M name){
        super(id);
        this.name = name;
    }

    public M getName() {
        return name;
    }

    public void setName(M name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Student{" + "name=" + name + ", id=" + id + '}';
    }
}
```

###### 2.2泛型接口

```
/**
 * 泛型接口：
 * 1.   在接口上定义泛型
 * 2.   测试：
 *          - 实例化测试
 *          - 子类型实现泛型接口的测试
 * */
public class Generic02Interface {
    public static void main(String[] args) {
        Cat c1 = new Cat(10);
        Cat c2 = new Cat(20);
        int x = c1.compare(c1,c2);
        System.out.println(x);
    }
}
interface MyComparable<M,T>{
    int compare(M o1, T o2);
}
class Cat implements MyComparable<Cat,Cat>{
    private int age;
    public Cat(int age) {
        this.age = age;
    }
    @Override
    public int compare(Cat o1, Cat o2) {
        return o1.age - o2.age;
    }
}
```

###### 2.3泛型方法

```
/**
 * 泛型方法：
 * 1. 泛型也可以只用在方法上
 * 2. 位置在返回值类型的前面
 * 3. 泛型方法只需要给形参传入具体的数据，类型是jvm主动推断出来的
 * */
public class Generic03Method {
    public static void main(String[] args) {
        String str1 = "hello";
        String str2 = "hello";
        System.out.println(Myutil.eq(str1,str2));

        StringBuilder sb1 = new StringBuilder("hello");
        StringBuilder sb2 = new StringBuilder("hello");
        System.out.println(Myutil.eq(sb1,sb2));
    }
}
class Myutil{
    public <T> void show(T t){
        System.out.println(t);
    }
    public static <T> boolean eq(T a, T b) {
        return a.equals(b);
    }
}
```

###### 2.4泛型通配符

```
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Generic04 {
    //?:泛型通配符。表示在定义期间关心的不是具体的类型
    //1. 在使用集合类型时，可以使用泛型通配符和使用T是一个效果
    //      我们关心的不是集合中的元素是什么类型
    //2.
    public static void print(List<?> list) {
        for (int i = 0; i < list.size(); i++) {
            System.out.print(list.get(i) + " ");
        }
    }

    public static void main(String[] args) {
        // Integer 集合，可以运行
        List<Integer> intList = Arrays.asList(0, 1, 2);
        print(intList);
        System.out.println();
        // String 集合，可以运行
        List<String> strList = Arrays.asList("0", "1", "2");
        print(strList);

    }
    public static void calUp(List<? extends B> list) {

    }
    public static void calDown(List<? super D> list) {

    }
    public void test(){
        List<A> alist = new ArrayList<>();
        List<B> bList = new ArrayList<>();
        List<C> cList = new ArrayList<>();
        List<D> dList = new ArrayList<>();
        List<E> eList = new ArrayList<>();

        calUp(bList);
        calUp(cList);
        calUp(dList);
        calUp(eList);
    }
    public void test1(){
        List<A> alist = new ArrayList<>();
        List<B> bList = new ArrayList<>();
        List<C> cList = new ArrayList<>();
        List<D> dList = new ArrayList<>();
        List<E> eList = new ArrayList<>();

        calDown(bList);
        calDown(cList);
        calDown(dList);
        calDown(alist);
    }
}
class A{}
class B extends A{}
class C extends B{}
class D extends C{}
class E extends D{}
```

泛型是一种特殊的类型，你可以把泛型用在类、接口、方法上，从而实现一些通用算法。

此外，使用泛型有三个步骤：定义类型变量、使用类型变量、确定类型变量。

在确定类型变量这一步中，你可以用泛型通配符来限制泛型的范围，从而实现一些特殊算法。